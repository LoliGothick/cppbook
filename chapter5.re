= 付録: オーバーロード解決

@<code>{テンプレートよりよく使うけど、テンプレートよりよくわからない！}

C++には同じ名前の関数を違う型の引数で実装できるオーバーロードという機能があります。
「オーバーロード解決」は関数の呼び出し式が与えられたときにどの実装を呼び出すのかを選択するプロセスの名称です。

//emlist[overload resolution][cpp]{
void func(int); // #1
void func(double); // #2

int main() {
    func(1); // calls #1
    func(0.0); // calls #2
}
//}

== Partial Order

数学的に正しい定義は各自で調べてもらうことにして、ここでは軽く説明することにする。

int型の順序はTotal Orderという順序を持っている。
Total Orderの特徴は@<code>{a < b}も@<code>{a > b}も@<code>{false}ときかつそのときに限り、
@<code>{a == b}が@<code>{true}になるということだ。

対して、Partial Orderは@<code>{a < b}も@<code>{a > b}も@<code>{false}であっても、
@<code>{a == b}が@<code>{true}ではない、つまり比較不能という状態が存在する。

オーバーロードの優先順位はPartial Orderで順序付けされる。
ある関数のオーバーロードの候補（overload candidates）が順序比較不能であるとき、
オーバーロード解決は曖昧となり、コンパイルに失敗する。

//emlist[][cpp]{
void func(int, double); // #1
void func(long, int); // #2

int main() {
    func(1, 1); // ambiguous
}
//}

この例では@<b>{#1}は第一引数、@<b>{#1}は第二引数がintで完全にマッチする。
しかし、@<b>{#1}は第二引数の呼び出しがintに対してlong、
@<b>{#1}は第一引数の呼び出しがintに対してdoubleとなっている。
結果、コンパイラはどちらを呼べばよいのかを判断できず、オーバーロード解決は曖昧となる。

読者の中にはdoubleよりlongのほうがintに近いのではないかと思われる方がいらっしゃるかもしれないが、
C++は@<b>{オーバーロード距離}のようなものを考慮するようにはなっていないため、完全に優先順位がつかない場合はすべて曖昧となる。

== オーバーロード解決順位

優先順位という言葉を定義せずに使ってしまっていた。
オーバーロードの優先順位はどのように設定されているのだろうか？

 * 1. ほげ 
 * 2. ほげ
 * 3. ほげ 
 * 4. ほげ
 * 5. ほげ
 * 6. ほげ

かなり簡略化されているが、順番で考えられない場合に出会うことはそうそうない。

== 
