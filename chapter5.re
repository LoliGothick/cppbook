= 付録: オーバーロード解決

@<code>{テンプレートよりよく使うけど、テンプレートよりよくわからない！}

C++には同じ名前の関数を違う型の引数で実装できるオーバーロードという機能があります。
「オーバーロード解決」は関数の呼び出し式が与えられたときにどの実装を呼び出すのかを選択するプロセスの名称です。

//emlist[overload resolution][cpp]{
void func(int); // #1
void func(double); // #2

int main() {
    func(1); // calls #1
    func(0.0); // calls #2
}
//}

== Partial Order

数学的に正しい定義は各自で調べてもらうことにして、ここでは軽く説明することにする。

int型の順序はTotal Orderという順序を持っている。
Total Orderの特徴は@<code>{a < b}も@<code>{a > b}も@<code>{false}ときかつそのときに限り、
@<code>{a == b}が@<code>{true}になるということだ。

対して、Partial Orderは@<code>{a < b}も@<code>{a > b}も@<code>{false}であっても、
@<code>{a == b}が@<code>{true}ではない、つまり比較不能という状態が存在する。

オーバーロードの優先順位はPartial Orderで順序付けされる。
ある関数のオーバーロードの候補（overload candidates）が順序比較不能であるとき、
オーバーロード解決は曖昧となり、コンパイルに失敗する。

//emlist[][cpp]{
void func(int, double); // #1
void func(long, int); // #2

int main() {
    func(1, 1); // ambiguous
}
//}

この例では@<b>{#1}は第一引数、@<b>{#1}は第二引数がintで完全にマッチする。
しかし、@<b>{#1}は第二引数の呼び出しがintに対してlong、
@<b>{#1}は第一引数の呼び出しがintに対してdoubleとなっている。
結果、コンパイラはどちらを呼べばよいのかを判断できず、オーバーロード解決は曖昧となる。

読者の中にはdoubleよりlongのほうがintに近いのではないかと思われる方がいらっしゃるかもしれないが、
C++は@<b>{オーバーロード距離}のようなものを考慮するようにはなっていないため、完全に優先順位がつかない場合はすべて曖昧となる。

== オーバーロード解決順位

優先順位という言葉を定義せずに使ってしまっていた。
オーバーロードの優先順位はどのように設定されているのだろうか？

 * 1. 完全なマッチ: すべての実引数の型が仮引数宣言の型と修飾子を含めて完全に一致する場合。
 * 2. 微調整によるマッチ: 1.に加えて非constからconstへの変換、配列から配列の先頭要素へのポインタへの変換などを許可してマッチする場合。
 * 3. プロモーションによるマッチ: 2.に加えてintからlong、floatからdoubleなど、安全かつ暗黙に変換を許可してマッチする場合。
 * 4. 標準変換のみによるマッチ: 3.に加えてintからfloatやpublicな基底クラスへの変換を。暗黙の変換演算子による変換や呼び出し可能なコンストラクタによる変換を含まない。
 * 5. ユーザー定義変換によるマッチ: 4.に加えて暗黙の変換演算子による変換や呼び出し可能なコンストラクタによる変換など、すべての変換を許可してマッチする場合。
 * 6. ellipsis (...): ほぼすべての型は省略記号にマッチする（ただし、非トリビアルなコピーコンストラクタを持つクラスはマッチしない）。

かなり簡略化されているが、この順番で考えられない場合に出会うことはそうそうない (initializer_listが例外だが、割愛する)。

== メンバ関数の暗黙の引数

メンバ関数は@<code>{*this}という暗黙の引数を第一引数に持つ。
@<code>{MyClass}のメンバ関数が持つ暗黙の第一引数の型は非constメンバ関数の場合@<code>{MyClass&}であり、
constメンバ関数の場合@<code>{MyClass const&}である。
C++11からは右辺値のバージョンが追加された。
右辺値の@<code>{MyClass}のメンバ関数が持つ暗黙の第一引数の型は非constメンバ関数の場合@<code>{MyClass&&}であり、
constメンバ関数の場合@<code>{MyClass const&&}である（const版を使うことはないだろうが）。

右辺値参照を使うと、左辺値にはマッチしなくなり、右辺値にのみマッチするようになる。

//emlist[][cpp]{
struct S {};

void func(S&);  // #1
void func(S&&); // #2

int main() {
    S s{};
    func(s); // calls #1
    func(s); // calls #2
}
//}

これはメンバ関数の暗黙の第一引数でも同じである。

//emlist[][cpp]{
struct watch_t {
    tick() const&; // #1
    tick() &&;     // #2
    tack() const&; // #3
};

int main() {
    watch_t watch{};
    watch.tick();     // calls #1
    watch_t{}.tick(); // calls #2
    // calls #3, because there is no overload for rvalue
    watch_t{}.tack(); 
}
//}
