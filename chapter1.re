= ｱｯ!この分岐「深い」ッ！！

== まえおき

読者も分岐が異常に複雑でネストが深いコードを目撃したことがあるのではないだろうか？
コントロールフローの複雑なコードはダメなコードの典型例と言っても過言ではないであろう。

複雑な処理を行わなければいけない場合、コードが複雑になるのは仕方がない。
しかし、あまりにも多くの場合分けを一つの関数に押し込めるのは間違いだと思う。

この章では、複雑な分岐をいかに簡潔にコーディングし、関数をどう分離するのかについて議論する。

== 分岐乱舞

 * 非負整数の負数チェック
 * すでにNull検査が済んでいるポインタのダブルチェック

など、一生通ることのない分岐を見ることがある。

//emlist[非負整数の負数チェック][cpp]{
// sizeofはstd::size_tを返すので絶対に真になることはない
if constexpr (sizeof(foo) < 0) {
  // ...
}
//}

//emlist[すでにNull検査が済んでいるポインタのダブルチェック][cpp]{
int* ptr
assert(ptr); // 一回目のチェック
if (ptr) { // assertするかハンドルするかどっちかにしろ
  // ...
} else {
  // ...
}
//}

非負整数の負数チェックの場合は修正が簡単で、単に取り除けばいい。

ポインタのダブルチェックの場合、assertするのが正しいのかハンドリングするのがわからない。
そのため、git blameを行い書いた人を問い詰めるか、自分でコードを読んで考えるしかない。

== 正常系と異常系

正常系と異常系が分けて書かれていないというのはコードのわかりにくさの原因のひとつになる。
先に異常系のチェックを行い異常値を返し、以降は正常系の処理を行うというのはよく知られた方法である。

新人が最初に書いた最初のプルリクエストでswitchとifを駆使したコードを見せてくれた。
残念ながら、紙面を圧迫するほど複雑なので疑似コードの掲載を断念せざるを得ない。

この問題へのより良い解答は、モナドを導入することだと思われる。
以下はRustのコードである。
コマンドの入力をパースして数字であれば2倍にして返す関数を書いてみる。

//emlist[Resultのモナド機能を駆使して書いたコマンドラインのパース][rust]{
fn twice_arg(mut argv: env::Args) -> Result<i32, CliError> {
    argv.nth(1)
        .ok_or(CliError::NotEnoughArgs)?
        .parse::<i32>()
        .map(|x| x * 2)
}
//}

このメソッドチェインはエラー処理を書いていない！
Rustの詳細な解説は省きますが、モナディック関数を使うとエラー処理をわざわざ全部書かなくて済みます。
エラーを合成するのです！

@<code>{ok_or}や@<code>{map}などの関数はコンビネータと呼ばれます。
@<code>{nth}や@<code>{parse}が@<code>{Option}や@<code>{Result}を返しており、
コンビネータがエラーを合成しているのです。

残念ながらC++にこのような高級な機能やライブラリは備わっていないのです。
ないであれば、モナドライブラリを作ればよいのです。

テンプレートライブラリを書く時間がない？
しかし、コンビネータは「失敗する可能性がある単位」で関数を分離するという重要な示唆を与えてくれます。
すくなくとも、エラーが起こる単位で関数に切り出すことを心がけたいところです。

== この章のまとめ

モナドがない言語が何をやってもダメ。
モナディック関数を作れ。

何種類ものエラーが起こるような関数を書かない。
エラーが起こる最小単位くらいで関数を切り分ける。
