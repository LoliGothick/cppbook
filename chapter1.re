= ｱｯ!この分岐「深い」ッ！！

== まえおき

読者も分岐が異常に複雑でネストが深いコードを目撃したことがあるのではないでしょうか？
コントロールフローの複雑なコードはダメなコードの典型例と言っても過言ではないでしょう。

複雑な処理を行わなければいけない場合、コードが複雑になるのは仕方がないでしょう。
しかし、あまりにも多くの場合分けを一つの関数に押し込めるのは間違いだと思います。

この章では、複雑な分岐をいかに簡潔にコーディングし、関数をどう分離するのかについて議論します。

== 分岐乱舞

 * 非負整数の負数チェック
 * すでにNull検査が済んでいるポインタのダブルチェック

など、一生通ることのない分岐を見ます。

//emlist[非負整数の負数チェック][cpp]{
// sizeofはstd::size_tを返すので絶対に真になることはない
if constexpr (sizeof(foo) < 0) {
  // ...
}
//}

//emlist[すでにNull検査が済んでいるポインタのダブルチェック][cpp]{
int* ptr;
assert(ptr); // 一回目のチェック
if (ptr) { // assertするかハンドルするかどっちかにしろ
  // ...
} else {
  // ...
}
//}

非負整数の負数チェックの場合は修正が簡単で、単に取り除けばいいです。

ポインタのダブルチェックの場合、assertするのが正しいのかハンドリングするのが正しいのかわからないです。
そのため、git blameを行い書いた人を問い詰めるか、自分でコードを読んで考えるしかないです。

== 正常系と異常系

正常系と異常系が分けて書かれていないというのはコードのわかりにくさの原因のひとつになります。
先に異常系のチェックを行い異常値を返し、以降は正常系の処理を行うというのはよく知られた方法です。

新人が最初に書いた最初のプルリクエストでswitchとifを駆使したコードを見せてくれました。
残念ながら、紙面を圧迫するほど複雑なので疑似コードの掲載を断念せざるを得ないです。

この問題へのより良い解答は、モナドを導入することだと思われます。
以下はRustのコードです。
コマンドの入力をパースして数字であれば2倍にして返す関数を書いてみます。

//emlist[Resultのモナド機能を駆使して書いたコマンドラインのパース][rust]{
fn twice_arg(mut argv: env::Args) -> Result<i32, CliError> {
    argv.nth(1)
        .ok_or(CliError::NotEnoughArgs)?
        .parse::<i32>()
        .map(|x| x * 2)
}
//}

このメソッドチェインはエラー処理を書いていないです！
Rustの詳細な解説は省きますが、モナディック関数を使うとエラー処理をわざわざ全部書かなくて済みます。
エラーを合成するのです！

@<code>{ok_or}や@<code>{map}などの関数はコンビネータと呼ばれます。
@<code>{nth}や@<code>{parse}が@<code>{Option}や@<code>{Result}を返しており、
コンビネータがエラーを合成しているのです。

残念ながらC++にこのような高級な機能やライブラリは備わっていないのです。
ないであれば、モナドライブラリを作ればよいのです。

テンプレートライブラリを書く時間がない？
しかし、コンビネータは「失敗する可能性がある単位」で関数を分離するという重要な示唆を与えてくれます。
すくなくとも、エラーが起こる単位で関数に切り出すことを心がけたいところです。

== この章のまとめ

モナドがない言語が何をやってもダメ。
モナディック関数を作れ。

何種類ものエラーが起こるような関数を書かない。
エラーが起こる最小単位くらいで関数を切り分ける。
